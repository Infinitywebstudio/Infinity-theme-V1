<?php
/**
 * Register Custom Gutenberg Blocks
 *
 * @package Infinity_2025_Simple
 */

/**
 * Style Collector - Collect dynamic styles for clean HTML
 */
class Infinity_Style_Collector {
    private static $styles = array();

    /**
     * Add a style rule
     */
    public static function add_style( $selector, $rules ) {
        if ( ! empty( $rules ) ) {
            self::$styles[ $selector ] = $rules;
        }
    }

    /**
     * Get all collected styles
     */
    public static function get_styles() {
        return self::$styles;
    }

    /**
     * Clear all collected styles
     */
    public static function clear_styles() {
        self::$styles = array();
    }
}

/**
 * Generate CSS file from post content
 */
function infinity_generate_post_css( $post_id ) {
    // Skip autosaves and revisions
    if ( wp_is_post_autosave( $post_id ) || wp_is_post_revision( $post_id ) ) {
        return;
    }

    // Get post content
    $post = get_post( $post_id );
    if ( ! $post || empty( $post->post_content ) ) {
        return;
    }

    // Don't generate CSS for trashed posts
    if ( $post->post_status === 'trash' ) {
        return;
    }

    // Get page slug or title for filename
    $page_slug = $post->post_name;

    // Remove __trashed suffix if it exists (shouldn't happen but just in case)
    $page_slug = preg_replace( '/__trashed.*$/', '', $page_slug );

    if ( empty( $page_slug ) ) {
        $page_slug = sanitize_title( $post->post_title );
    }
    if ( empty( $page_slug ) ) {
        $page_slug = $post_id;
    }

    // Parse blocks
    $blocks = parse_blocks( $post->post_content );
    $css_rules = array();

    // Extract styles from infinity/container blocks
    infinity_extract_container_styles( $blocks, $css_rules );

    // Generate CSS file with proper formatting
    if ( ! empty( $css_rules ) ) {
        $css_content = "/**\n * Generated CSS for: {$post->post_title}\n * Post ID: {$post_id} | Slug: {$page_slug}\n * Auto-generated by Infinity Container blocks\n */\n\n";

        foreach ( $css_rules as $selector => $rules ) {
            $css_content .= $selector . " {\n";
            foreach ( $rules as $rule ) {
                $css_content .= "    " . $rule . ";\n";
            }
            $css_content .= "}\n\n";
        }

        // Save to file
        $css_dir = INFINITY_DIR . '/assets/css/pages';
        if ( ! file_exists( $css_dir ) ) {
            wp_mkdir_p( $css_dir );
        }

        $css_file = $css_dir . '/page-' . $page_slug . '.css';
        file_put_contents( $css_file, $css_content );
    }
}

/**
 * Recursively extract styles from container blocks
 */
function infinity_extract_container_styles( $blocks, &$css_rules ) {
    foreach ( $blocks as $block ) {
        if ( $block['blockName'] === 'infinity/container' && ! empty( $block['attrs'] ) ) {
            $attrs = $block['attrs'];
            $rules = array();

            // Dimensions
            if ( ! empty( $attrs['width'] ) ) {
                $rules[] = 'width:' . esc_attr( $attrs['width'] );
            }
            if ( ! empty( $attrs['height'] ) ) {
                $rules[] = 'height:' . esc_attr( $attrs['height'] );
            }

            // Layout
            if ( ! empty( $attrs['display'] ) ) {
                $rules[] = 'display:' . esc_attr( $attrs['display'] );
            }
            if ( ! empty( $attrs['flexDirection'] ) ) {
                $rules[] = 'flex-direction:' . esc_attr( $attrs['flexDirection'] );
            }
            if ( ! empty( $attrs['justifyContent'] ) ) {
                $rules[] = 'justify-content:' . esc_attr( $attrs['justifyContent'] );
            }
            if ( ! empty( $attrs['alignItems'] ) ) {
                $rules[] = 'align-items:' . esc_attr( $attrs['alignItems'] );
            }

            // Gap handling - use new gapRow and gapColumn if set, fallback to old gap
            if ( ! empty( $attrs['gapRow'] ) && ! empty( $attrs['gapColumn'] ) ) {
                $rules[] = 'gap:' . esc_attr( $attrs['gapRow'] ) . ' ' . esc_attr( $attrs['gapColumn'] );
            } elseif ( ! empty( $attrs['gapRow'] ) ) {
                $rules[] = 'gap:' . esc_attr( $attrs['gapRow'] );
            } elseif ( ! empty( $attrs['gapColumn'] ) ) {
                $rules[] = 'gap:' . esc_attr( $attrs['gapColumn'] );
            } elseif ( ! empty( $attrs['gap'] ) ) {
                $rules[] = 'gap:' . esc_attr( $attrs['gap'] );
            }

            if ( ! empty( $attrs['gridTemplateColumns'] ) ) {
                $rules[] = 'grid-template-columns:' . esc_attr( $attrs['gridTemplateColumns'] );
            }

            // Background
            if ( ! empty( $attrs['backgroundColor'] ) ) {
                $rules[] = 'background-color:' . esc_attr( $attrs['backgroundColor'] );
            }
            if ( ! empty( $attrs['backgroundImage'] ) ) {
                $rules[] = 'background-image:url(' . esc_url( $attrs['backgroundImage'] ) . ')';
                $rules[] = 'background-size:cover';
                $rules[] = 'background-position:center';
            }

            // Padding (optimized shorthand)
            $padding_values = array(
                'top' => ! empty( $attrs['paddingTop'] ) ? $attrs['paddingTop'] : null,
                'right' => ! empty( $attrs['paddingRight'] ) ? $attrs['paddingRight'] : null,
                'bottom' => ! empty( $attrs['paddingBottom'] ) ? $attrs['paddingBottom'] : null,
                'left' => ! empty( $attrs['paddingLeft'] ) ? $attrs['paddingLeft'] : null,
            );
            $padding_values = array_filter( $padding_values );

            if ( ! empty( $padding_values ) && count( $padding_values ) === 4 ) {
                $top = $padding_values['top'];
                $right = $padding_values['right'];
                $bottom = $padding_values['bottom'];
                $left = $padding_values['left'];

                if ( $top === $right && $top === $bottom && $top === $left ) {
                    // All 4 sides equal: padding: 10px
                    $rules[] = 'padding:' . esc_attr( $top );
                } elseif ( $top === $bottom && $right === $left ) {
                    // Vertical and horizontal equal: padding: 10px 20px
                    $rules[] = 'padding:' . esc_attr( $top ) . ' ' . esc_attr( $right );
                } elseif ( $right === $left ) {
                    // Right and left equal: padding: 10px 20px 30px
                    $rules[] = 'padding:' . esc_attr( $top ) . ' ' . esc_attr( $right ) . ' ' . esc_attr( $bottom );
                } else {
                    // All different: padding: 10px 20px 30px 40px
                    $rules[] = 'padding:' . esc_attr( $top ) . ' ' . esc_attr( $right ) . ' ' . esc_attr( $bottom ) . ' ' . esc_attr( $left );
                }
            } elseif ( ! empty( $padding_values ) ) {
                // Not all 4 sides set: use individual properties
                if ( isset( $padding_values['top'] ) ) {
                    $rules[] = 'padding-top:' . esc_attr( $padding_values['top'] );
                }
                if ( isset( $padding_values['right'] ) ) {
                    $rules[] = 'padding-right:' . esc_attr( $padding_values['right'] );
                }
                if ( isset( $padding_values['bottom'] ) ) {
                    $rules[] = 'padding-bottom:' . esc_attr( $padding_values['bottom'] );
                }
                if ( isset( $padding_values['left'] ) ) {
                    $rules[] = 'padding-left:' . esc_attr( $padding_values['left'] );
                }
            }

            // Margin (optimized shorthand)
            $margin_values = array(
                'top' => ! empty( $attrs['marginTop'] ) ? $attrs['marginTop'] : null,
                'right' => ! empty( $attrs['marginRight'] ) ? $attrs['marginRight'] : null,
                'bottom' => ! empty( $attrs['marginBottom'] ) ? $attrs['marginBottom'] : null,
                'left' => ! empty( $attrs['marginLeft'] ) ? $attrs['marginLeft'] : null,
            );
            $margin_values = array_filter( $margin_values );

            if ( ! empty( $margin_values ) && count( $margin_values ) === 4 ) {
                $top = $margin_values['top'];
                $right = $margin_values['right'];
                $bottom = $margin_values['bottom'];
                $left = $margin_values['left'];

                if ( $top === $right && $top === $bottom && $top === $left ) {
                    // All 4 sides equal: margin: 10px
                    $rules[] = 'margin:' . esc_attr( $top );
                } elseif ( $top === $bottom && $right === $left ) {
                    // Vertical and horizontal equal: margin: 10px 20px
                    $rules[] = 'margin:' . esc_attr( $top ) . ' ' . esc_attr( $right );
                } elseif ( $right === $left ) {
                    // Right and left equal: margin: 10px 20px 30px
                    $rules[] = 'margin:' . esc_attr( $top ) . ' ' . esc_attr( $right ) . ' ' . esc_attr( $bottom );
                } else {
                    // All different: margin: 10px 20px 30px 40px
                    $rules[] = 'margin:' . esc_attr( $top ) . ' ' . esc_attr( $right ) . ' ' . esc_attr( $bottom ) . ' ' . esc_attr( $left );
                }
            } elseif ( ! empty( $margin_values ) ) {
                // Not all 4 sides set: use individual properties
                if ( isset( $margin_values['top'] ) ) {
                    $rules[] = 'margin-top:' . esc_attr( $margin_values['top'] );
                }
                if ( isset( $margin_values['right'] ) ) {
                    $rules[] = 'margin-right:' . esc_attr( $margin_values['right'] );
                }
                if ( isset( $margin_values['bottom'] ) ) {
                    $rules[] = 'margin-bottom:' . esc_attr( $margin_values['bottom'] );
                }
                if ( isset( $margin_values['left'] ) ) {
                    $rules[] = 'margin-left:' . esc_attr( $margin_values['left'] );
                }
            }

            // Border Width (optimized shorthand with 0 values included)
            // Always get all 4 values, defaulting to '0' for empty sides
            $top = ! empty( $attrs['borderWidthTop'] ) ? $attrs['borderWidthTop'] : '0';
            $right = ! empty( $attrs['borderWidthRight'] ) ? $attrs['borderWidthRight'] : '0';
            $bottom = ! empty( $attrs['borderWidthBottom'] ) ? $attrs['borderWidthBottom'] : '0';
            $left = ! empty( $attrs['borderWidthLeft'] ) ? $attrs['borderWidthLeft'] : '0';

            // Check if at least one border width has a non-zero value
            $has_border = false;
            if ( ( $top !== '0' && $top !== '0px' && $top !== '0rem' && $top !== '0em' ) ||
                 ( $right !== '0' && $right !== '0px' && $right !== '0rem' && $right !== '0em' ) ||
                 ( $bottom !== '0' && $bottom !== '0px' && $bottom !== '0rem' && $bottom !== '0em' ) ||
                 ( $left !== '0' && $left !== '0px' && $left !== '0rem' && $left !== '0em' ) ) {
                $has_border = true;
            }

            if ( $has_border ) {
                $border_style = ! empty( $attrs['borderStyle'] ) ? esc_attr( $attrs['borderStyle'] ) : 'solid';
                $border_color = ! empty( $attrs['borderColor'] ) ? esc_attr( $attrs['borderColor'] ) : '';

                // Normalize zero values to '0' for comparison
                $top_normalized = ( $top === '0px' || $top === '0rem' || $top === '0em' ) ? '0' : $top;
                $right_normalized = ( $right === '0px' || $right === '0rem' || $right === '0em' ) ? '0' : $right;
                $bottom_normalized = ( $bottom === '0px' || $bottom === '0rem' || $bottom === '0em' ) ? '0' : $bottom;
                $left_normalized = ( $left === '0px' || $left === '0rem' || $left === '0em' ) ? '0' : $left;

                // Check if we can use ultra-shorthand: border: 1px solid red (all 4 sides equal and non-zero)
                if ( $top_normalized === $right_normalized && $top_normalized === $bottom_normalized &&
                     $top_normalized === $left_normalized && $top_normalized !== '0' && $border_color ) {
                    // All sides equal (non-zero) + color: use border shorthand
                    $rules[] = 'border:' . esc_attr( $top ) . ' ' . $border_style . ' ' . $border_color;
                } elseif ( $top_normalized === $right_normalized && $top_normalized === $bottom_normalized &&
                           $top_normalized === $left_normalized && $top_normalized !== '0' ) {
                    // All 4 sides equal (non-zero) without color
                    if ( $border_color ) {
                        $rules[] = 'border:' . esc_attr( $top ) . ' ' . $border_style . ' ' . $border_color;
                    } else {
                        $rules[] = 'border:' . esc_attr( $top ) . ' ' . $border_style;
                    }
                } else {
                    // Use individual border properties for each non-zero side
                    if ( $top_normalized !== '0' ) {
                        if ( $border_color ) {
                            $rules[] = 'border-top:' . esc_attr( $top_normalized ) . ' ' . $border_style . ' ' . $border_color;
                        } else {
                            $rules[] = 'border-top:' . esc_attr( $top_normalized ) . ' ' . $border_style;
                        }
                    }
                    if ( $right_normalized !== '0' ) {
                        if ( $border_color ) {
                            $rules[] = 'border-right:' . esc_attr( $right_normalized ) . ' ' . $border_style . ' ' . $border_color;
                        } else {
                            $rules[] = 'border-right:' . esc_attr( $right_normalized ) . ' ' . $border_style;
                        }
                    }
                    if ( $bottom_normalized !== '0' ) {
                        if ( $border_color ) {
                            $rules[] = 'border-bottom:' . esc_attr( $bottom_normalized ) . ' ' . $border_style . ' ' . $border_color;
                        } else {
                            $rules[] = 'border-bottom:' . esc_attr( $bottom_normalized ) . ' ' . $border_style;
                        }
                    }
                    if ( $left_normalized !== '0' ) {
                        if ( $border_color ) {
                            $rules[] = 'border-left:' . esc_attr( $left_normalized ) . ' ' . $border_style . ' ' . $border_color;
                        } else {
                            $rules[] = 'border-left:' . esc_attr( $left_normalized ) . ' ' . $border_style;
                        }
                    }
                }
            }

            // Border Radius (optimized shorthand)
            // Note: border-radius uses different syntax: top-left, top-right, bottom-right, bottom-left
            $border_radius_values = array(
                'top-left' => ! empty( $attrs['borderRadiusTopLeft'] ) ? $attrs['borderRadiusTopLeft'] : null,
                'top-right' => ! empty( $attrs['borderRadiusTopRight'] ) ? $attrs['borderRadiusTopRight'] : null,
                'bottom-right' => ! empty( $attrs['borderRadiusBottomRight'] ) ? $attrs['borderRadiusBottomRight'] : null,
                'bottom-left' => ! empty( $attrs['borderRadiusBottomLeft'] ) ? $attrs['borderRadiusBottomLeft'] : null,
            );
            $border_radius_values = array_filter( $border_radius_values );

            if ( ! empty( $border_radius_values ) && count( $border_radius_values ) === 4 ) {
                $tl = $border_radius_values['top-left'];
                $tr = $border_radius_values['top-right'];
                $br = $border_radius_values['bottom-right'];
                $bl = $border_radius_values['bottom-left'];

                if ( $tl === $tr && $tl === $br && $tl === $bl ) {
                    // All 4 corners equal: border-radius: 10px
                    $rules[] = 'border-radius:' . esc_attr( $tl );
                } elseif ( $tl === $br && $tr === $bl ) {
                    // Diagonal corners equal: border-radius: 10px 20px
                    $rules[] = 'border-radius:' . esc_attr( $tl ) . ' ' . esc_attr( $tr );
                } elseif ( $tr === $bl ) {
                    // Top-right and bottom-left equal: border-radius: 10px 20px 30px
                    $rules[] = 'border-radius:' . esc_attr( $tl ) . ' ' . esc_attr( $tr ) . ' ' . esc_attr( $br );
                } else {
                    // All different: border-radius: 10px 20px 30px 40px
                    $rules[] = 'border-radius:' . esc_attr( $tl ) . ' ' . esc_attr( $tr ) . ' ' . esc_attr( $br ) . ' ' . esc_attr( $bl );
                }
            } elseif ( ! empty( $border_radius_values ) ) {
                // Not all 4 corners set: use individual properties
                if ( isset( $border_radius_values['top-left'] ) ) {
                    $rules[] = 'border-top-left-radius:' . esc_attr( $border_radius_values['top-left'] );
                }
                if ( isset( $border_radius_values['top-right'] ) ) {
                    $rules[] = 'border-top-right-radius:' . esc_attr( $border_radius_values['top-right'] );
                }
                if ( isset( $border_radius_values['bottom-right'] ) ) {
                    $rules[] = 'border-bottom-right-radius:' . esc_attr( $border_radius_values['bottom-right'] );
                }
                if ( isset( $border_radius_values['bottom-left'] ) ) {
                    $rules[] = 'border-bottom-left-radius:' . esc_attr( $border_radius_values['bottom-left'] );
                }
            }

            // Determine class
            if ( ! empty( $attrs['customClass'] ) ) {
                // Replace spaces with dots for multiple classes or sanitize
                $class = esc_attr( $attrs['customClass'] );
                // Convert spaces to dots for CSS selector (e.g., "class1 class2" becomes ".class1.class2")
                $selector = '.' . str_replace( ' ', '.', trim( $class ) );
            } else {
                $selector = '.inf-' . substr( md5( serialize( $attrs ) ), 0, 8 );
            }

            if ( ! empty( $rules ) ) {
                $css_rules[ $selector ] = $rules;
            }
        }

        // Recursively process inner blocks
        if ( ! empty( $block['innerBlocks'] ) ) {
            infinity_extract_container_styles( $block['innerBlocks'], $css_rules );
        }
    }
}

/**
 * Hook: Generate CSS on post save
 */
add_action( 'save_post', 'infinity_generate_post_css', 10, 1 );

/**
 * Delete generated CSS file when post is trashed or deleted
 */
function infinity_delete_post_css( $post_id ) {
    // Get post BEFORE it's trashed (slug is still clean)
    $post = get_post( $post_id );
    if ( ! $post ) {
        return;
    }

    // Get original slug (before __trashed is added)
    $page_slug = $post->post_name;

    // Remove __trashed suffix if it exists
    $page_slug = preg_replace( '/__trashed.*$/', '', $page_slug );

    if ( empty( $page_slug ) ) {
        $page_slug = sanitize_title( $post->post_title );
    }
    if ( empty( $page_slug ) ) {
        $page_slug = $post_id;
    }

    // Delete CSS file with original slug
    $css_file = INFINITY_DIR . '/assets/css/pages/page-' . $page_slug . '.css';
    if ( file_exists( $css_file ) ) {
        unlink( $css_file );
    }

    // Also delete file with __trashed suffix (in case it exists)
    $css_file_trashed = INFINITY_DIR . '/assets/css/pages/page-' . $post->post_name . '.css';
    if ( file_exists( $css_file_trashed ) && $css_file_trashed !== $css_file ) {
        unlink( $css_file_trashed );
    }

    // Also try to delete with post ID (for backward compatibility)
    $css_file_id = INFINITY_DIR . '/assets/css/pages/page-' . $post_id . '.css';
    if ( file_exists( $css_file_id ) ) {
        unlink( $css_file_id );
    }
}
add_action( 'wp_trash_post', 'infinity_delete_post_css', 10, 1 );
add_action( 'before_delete_post', 'infinity_delete_post_css', 10, 1 );
add_action( 'delete_post', 'infinity_delete_post_css', 10, 1 );

/**
 * Enqueue generated CSS file in head
 */
function infinity_enqueue_page_css() {
    if ( is_singular() ) {
        $post_id = get_the_ID();
        $post = get_post( $post_id );

        // Get page slug for filename
        $page_slug = $post->post_name;
        if ( empty( $page_slug ) ) {
            $page_slug = sanitize_title( $post->post_title );
        }
        if ( empty( $page_slug ) ) {
            $page_slug = $post_id;
        }

        $css_file = INFINITY_DIR . '/assets/css/pages/page-' . $page_slug . '.css';
        $css_url = INFINITY_URI . '/assets/css/pages/page-' . $page_slug . '.css';

        if ( file_exists( $css_file ) ) {
            wp_enqueue_style( 'infinity-page-' . $page_slug, $css_url, array(), filemtime( $css_file ) );
        }
    }
}
add_action( 'wp_enqueue_scripts', 'infinity_enqueue_page_css', 20 );


/**
 * Register block scripts and styles
 */
function infinity_register_block_assets() {
    // Register the block editor script
    wp_register_script(
        'infinity-container-editor',
        INFINITY_URI . '/inc/blocks/infinity-container/index.js',
        array( 'wp-blocks', 'wp-element', 'wp-editor', 'wp-block-editor', 'wp-components' ),
        INFINITY_VERSION,
        true
    );

    // Register the block style
    wp_register_style(
        'infinity-container-style',
        INFINITY_URI . '/inc/blocks/infinity-container/style.css',
        array(),
        INFINITY_VERSION
    );

    // Register the editor style
    wp_register_style(
        'infinity-container-editor-style',
        INFINITY_URI . '/inc/blocks/infinity-container/editor.css',
        array(),
        INFINITY_VERSION
    );

    // Register the padding-margin editor style
    wp_register_style(
        'infinity-spacing-editor-style',
        INFINITY_URI . '/inc/blocks/infinity-container/padding-margin.css',
        array(),
        INFINITY_VERSION
    );
}
add_action( 'init', 'infinity_register_block_assets' );

/**
 * Register Infinity Container Block
 */
function infinity_register_blocks() {
    // Register Infinity Container block
    register_block_type( 'infinity/container', array(
        'editor_script'   => 'infinity-container-editor',
        'editor_style'    => array( 'infinity-container-editor-style', 'infinity-spacing-editor-style' ),
        'style'           => 'infinity-container-style',
        'render_callback' => 'infinity_container_render_callback',
        'attributes'      => array(
            'customClass'        => array( 'type' => 'string', 'default' => '' ),
            'width'              => array( 'type' => 'string', 'default' => '' ),
            'height'             => array( 'type' => 'string', 'default' => '' ),
            'paddingTop'         => array( 'type' => 'string', 'default' => '' ),
            'paddingRight'       => array( 'type' => 'string', 'default' => '' ),
            'paddingBottom'      => array( 'type' => 'string', 'default' => '' ),
            'paddingLeft'        => array( 'type' => 'string', 'default' => '' ),
            'marginTop'          => array( 'type' => 'string', 'default' => '' ),
            'marginRight'        => array( 'type' => 'string', 'default' => '' ),
            'marginBottom'       => array( 'type' => 'string', 'default' => '' ),
            'marginLeft'         => array( 'type' => 'string', 'default' => '' ),
            'gapRow'             => array( 'type' => 'string', 'default' => '' ),
            'gapColumn'          => array( 'type' => 'string', 'default' => '' ),
            'backgroundColor'       => array( 'type' => 'string', 'default' => '' ),
            'backgroundImage'       => array( 'type' => 'string', 'default' => '' ),
            'borderColor'           => array( 'type' => 'string', 'default' => '' ),
            'borderWidth'           => array( 'type' => 'string', 'default' => '' ),
            'borderWidthTop'        => array( 'type' => 'string', 'default' => '' ),
            'borderWidthRight'      => array( 'type' => 'string', 'default' => '' ),
            'borderWidthBottom'     => array( 'type' => 'string', 'default' => '' ),
            'borderWidthLeft'       => array( 'type' => 'string', 'default' => '' ),
            'borderRadius'          => array( 'type' => 'string', 'default' => '' ),
            'borderRadiusTopLeft'   => array( 'type' => 'string', 'default' => '' ),
            'borderRadiusTopRight'  => array( 'type' => 'string', 'default' => '' ),
            'borderRadiusBottomRight' => array( 'type' => 'string', 'default' => '' ),
            'borderRadiusBottomLeft' => array( 'type' => 'string', 'default' => '' ),
            'borderStyle'           => array( 'type' => 'string', 'default' => 'solid' ),
            'display'            => array( 'type' => 'string', 'default' => '' ),
            'flexDirection'      => array( 'type' => 'string', 'default' => '' ),
            'justifyContent'     => array( 'type' => 'string', 'default' => '' ),
            'alignItems'         => array( 'type' => 'string', 'default' => '' ),
            'gap'                => array( 'type' => 'string', 'default' => '' ),
            'gridTemplateColumns' => array( 'type' => 'string', 'default' => '' ),
        ),
    ) );
}
add_action( 'init', 'infinity_register_blocks' );

/**
 * Render callback for Infinity Container block
 */
function infinity_container_render_callback( $attributes, $content, $block ) {
    // Le contenu des InnerBlocks est déjà dans $content grâce à InnerBlocks.Content
    // Si vide, essayer de récupérer depuis $block (fallback)
    if ( empty( $content ) ) {
        if ( ! empty( $block->inner_html ) ) {
            $content = $block->inner_html;
        } elseif ( ! empty( $block->inner_blocks ) ) {
            $content = '';
            foreach ( $block->inner_blocks as $inner_block ) {
                $content .= render_block( $inner_block );
            }
        }
    }

    // Include the render template
    ob_start();
    include INFINITY_DIR . '/inc/blocks/infinity-container/render.php';
    return ob_get_clean();
}
